## Secret
[secret.yaml](../practice/4.saving-configurations/2.secret/secret.yaml)

ConfigMap явно плохо подходит, для хранения каких-то чувствительных данных. 

Секрет - отдельная сущновсть куба для создания и хранения секретов.
Следует понимать, что серкрет не шифрует данные, а только кодирует в Base64. 
В чем тогда польза? Полза в том, что к секретам можно ограничить доступ. Например, чел у которого стандартная роль 
разработчика с правами просматривать и конфигурить деплои не будет иметь доступа
к сертерам ни на редактирование, ни на просмотр

Секреты бывают:
- generic - пароли/токены для приложений
- docker-registry - данные авторизации в docker registry
- tls - TLS сертификаты для Ingress

Создадим секрет руками
```bash
  kubectl create secret generic test --from-literal=test1=asdf --from-literal=dbpassword=1q2w3e --save-config
```
```bash
  kubectl get secret
  NAME   TYPE     DATA   AGE
  test   Opaque   2      3m4s
```
Видим секрет с именем test, тип Opaque(исторически так называется тут generic), data - два ключа

Посмторим что внутри
```bash
  kubectl get secret test -o yaml
```
```bash
  apiVersion: v1
data:
  dbpassword: MXEydzNl # закодирован в Base64
  test1: YXNkZg==
kind: Secret
metadata:
  creationTimestamp: "2026-02-24T17:12:38Z"
  name: test
  namespace: default
  resourceVersion: "15700"
  uid: 8e6b4432-d3c4-41ec-81dc-6f772e7c0075
type: Opaque
```

Теперь если мы посмотри на деплоймент с секретом
[deployment-with-secret.yaml](../practice/4.saving-configurations/2.secret/deployment-with-secret.yaml)

Мы можем как и переменные, передавать ссылаясь на секрет
```bash
  envFrom:
    - secretRef:
      name: test
```

НО в кубе есть еще способ, точечно передавать перменные окружения, т.е. не весь секрет/cm шарить, а ровно то что нужно 
НО когда мы шарим весь ямл, то и переменные будут называться как ключ в мапе. В нашем же случае мы сами задаем 
имя переменной - TEST_1
```bash
        env:
        - name: TEST_1 # создай переменную TEST_1
          valueFrom:
            secretKeyRef: 
              name: test # из секрета test
              key: test1 # по ключу test1
```

катнем деплоймент с секретом и посмотрим в контейнере, переменные окружения

катнем секрет
```bash
kubectl apply -f secret.yaml
```
затем деплоймент
```bash
kubectl apply -f deployment-with-secret.yaml 
```

чекаем что внутри. В describe мы как и ранее не сможем увидеть значения
```bash
kubectl exec -it my-deployment-5fdd7c8d46-2hn96 -- env
```
```bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=my-deployment-5fdd7c8d46-2hn96
TERM=xterm
DEBUG=false
dbhost=postgresql
TEST=foo
TEST_1=asdf # вот наш из секрета
KUBERNETES_SERVICE_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT=tcp://10.96.0.1:443
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
KUBERNETES_PORT_443_TCP_PROTO=tcp
KUBERNETES_PORT_443_TCP_PORT=443
KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
KUBERNETES_SERVICE_HOST=10.96.0.1
NGINX_VERSION=1.12.2-1~stretch
NJS_VERSION=1.12.2.0.1.14-1~stretch
HOME=/root
```

Следует обратить внимание, что в config.yaml есть поле stringData. Это поле для того, чтобы никто не 
заморачивался кодировать и раскодировать секреты. Можно писать отрытым текстом, а кубер при деплое перекодирует это 
в base64

```bash
apiVersion: v1
kind: Secret
metadata:
  name: test
stringData:
  test: updated
```

и если мы сейчас посмотрим, что внутри секрета, то увидим закодированное велью для нашего ключа test
```bash
kubectl get secret test -o yaml
```
```bash
apiVersion: v1
data:
  test: dXBkYXRlZA== # Закодировано кубом
kind: Secret
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","kind":"Secret","metadata":{"annotations":{},"name":"test","namespace":"default"},"stringData":{"test":"updated"}}
  creationTimestamp: "2026-02-24T17:31:33Z"
  name: test
  namespace: default
  resourceVersion: "16650"
  uid: e87abd3e-7c93-4c5b-b4ea-d04af2b09b55
type: Opaque
```