## ConfigMap As File
[configmap.yaml](../practice/4.saving-configurations/3.configmap/configmap.yaml)

Мы можем монтировать в контейнеры не только переменные окружения, а содержимое cm и секретов в виде файлов. 
Т.е. мы можем в конфиге хранить не только ключ-значение, а и сделать ключ, а значением многострочное что-то, 
что будет преобразовано в файл. Мы ссылку на этот конфигМап укажем в манифесте деплоймента в специальном разделе 
volumes, который будет создан из конфигМапы и у нас в контейнере появится файл.

```bash
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-configmap
data:
  default.conf: | # вертикальная черта говорит о том, что дальше многострочный код
    server {
        listen       80 default_server;
        server_name  _;

        default_type text/plain;

        location / {
            return 200 '$hostname\n';
        }
    }
```
default.conf - имя файла, который будет создан в контейнере
server - дефолтная конфигурация от nginx, которую мы хотим разместить в контейнере в виде файла

накатим cm
```bash
kubectl apply -f configmap.yaml 
```
и теперь посмотрим манифест деплоймента
[deployment-with-configmap.yaml](../practice/4.saving-configurations/3.configmap/deployment-with-configmap.yaml)

У нас тут появляются новые разделы: volumeMounts и volumes
```bash
    spec:
      containers:
      - image: quay.io/testing-farm/nginx:1.12
        name: nginx
        ports:
        - containerPort: 80
        resources:
          requests:
            cpu: 10m
            memory: 100Mi
          limits:
            cpu: 100m
            memory: 100Mi
        volumeMounts:
        - name: config
          mountPath: /etc/nginx/conf.d/
      volumes:
      - name: config
        configMap:
          name: my-configmap
```

- volumeMounts - находится на уровне описания контейнера. Он описывает точки монтирования внутри контейнера. 
Мы указываем, что в контейнере, в точку /etc/nginx/conf.d/ надо смотировать том, которвй насывается config.

- volumes - находится на уровне описания спеки. Описывается, что у нас есть том, с названием config, 
который должен быть создан из конфигМапа с именем my-configmap

Простыми словами в каталог /etc/nginx/conf.d/ будет создан файл с названием default.conf и со значенями 
этого ключа в configMap !!! Дополнение!!! Фалик на самом деле будет лежать в другом месте со страшным названием пакета, 
а у нас в /etc/nginx/conf.d/ будет линк на него

накатим наш деплоймент (configMap мы катнули выше)
```bash
kubectl apply -f deployment-with-configmap.yaml 
```

Зайдем в контейнер и чекнем файл
```bash
kubectl exec -it my-deployment-8bf6cdc59-td7nf -- bash
cd /etc/nginx/conf.d/
ls
cat default.conf 
```

Видим:
```bash
server {
    listen       80 default_server;
    server_name  _;

    default_type text/plain;

    location / {
        return 200 '$hostname\n';
    }
}
```

Выйдем из контейнера (ctrl + D)

Выполним и получим в ответ название нашего пода
```bash
kubectl port-forward my-deployment-8bf6cdc59-td7nf 18080:80
# Делать в разных терминалах!!!!
curl 127.0.0.1:18080
# Убить занятый порт если что
lsof -i :8080 # получим PID порта
kill pid_порта 
```
- port-forward - позволяет редиректить локальные запросы в контейнер
- 8080:80 - 8080 - это порт локальный, который будет слушать куб, 80 - порт, 
куда будет переправлять в контейнер(nginx слушает 80 согласно нашего конфига)


!!!! Если внести изменения в наш конфигМап и перекатить его, то в отличии от переменных окружения 
куб применит изменения в созданном ранее файле. Не мгоновенно, за какое-то время - около минуты может
Файл заменится, но в нашем случае nginx не отвечает нам новым изменениями в файле. 
Все потому, что кубер файл поменял без проблем, но nginx ничего об это не знает. И куб его не перекатывал. 
Идея такая, что приложение должно само уметь следить за фалами и перекатываться, если надо

